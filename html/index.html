<!doctype html>
<html lang="uk">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,viewport-fit=cover" />
<title>Тепінг-тест Ільїна (30 с, 6×5 с)</title>
<style>
  :root{
    --bg:#f7f8fb; --fg:#111; --muted:#62646a; --card:#fff; --accent:#2b6ef6; --ok:#16a34a; --warn:#ef4444;
    --gap:10px;
  }
  html{height:100%}
  body{margin:0; font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial; background:var(--bg); color:var(--fg); min-height:100vh; overflow-x:hidden;}
  .wrap{
    width:100%; max-width:820px; margin:0 auto; padding:10px;
    display:flex; flex-direction:column; gap:8px; min-height:100vh; box-sizing:border-box;
  }
  h1{font-size:1.05rem; margin:0}
  .row{display:flex; gap:8px; flex-wrap:wrap}
  .card{background:var(--card); border-radius:12px; padding:10px; box-shadow:0 1px 2px rgba(0,0,0,.06)}
  label{font-size:.85rem; color:var(--muted); display:block; margin-bottom:3px}
  input,select{width:100%; padding:10px; border-radius:10px; border:1px solid #e5e7eb; background:#fff; font-size:1rem; box-sizing:border-box; appearance:none}
  select{background-image:url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e"); background-position:right 10px center; background-repeat:no-repeat; background-size:16px; padding-right:40px}
  input:focus,select:focus{outline:none; border-color:var(--accent); box-shadow:0 0 0 3px rgba(43,110,246,0.1)}
  .input-group{position:relative; display:block}
  .input-group input{width:100%; padding-right:45px}
  .copy-btn{position:absolute; right:8px; top:50%; transform:translateY(-50%); background:#f3f4f6; border:0; color:#6b7280; cursor:pointer; font-size:0.8rem; padding:4px 8px; border-radius:6px; transition:all 0.2s; display:flex; align-items:center; justify-content:center; opacity:0; pointer-events:none}
  .input-group:focus-within .copy-btn{opacity:1; pointer-events:auto}
  .copy-btn:hover{background:#e5e7eb; color:#374151}
  .copy-btn:active{background:#d1d5db}
  .copy-btn.copied{color:#16a34a; background:#dcfce7}
  button{padding:12px 16px; border:0; border-radius:12px; font-size:1.05rem; cursor:pointer}
  .primary{background:#16a34a; color:#fff} /* Changed to green */
  .primary:hover{background:#15803d}
  .primary:active{background:#166534}
  .secondary{background:#eef2ff; color:#1f2937}
  .danger{background:#ffe4e6; color:#991b1b}
  .timer{font-size:1.5rem; font-weight:700}
  .small{font-size:.9rem; color:#444}
  .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; font-size:.9rem}
  .hdr{display:grid; grid-template-columns:1fr auto; align-items:center}
  .pill{display:inline-block; padding:2px 8px; border-radius:999px; background:#f3f4f6; font-size:.75rem; color:#374151}
  .startbar{display:flex; justify-content:center; gap:8px; align-items:center;}
  .startbar .primary{min-width:180px}
  .grid{display:grid; grid-template-columns:repeat(2,1fr); grid-auto-rows: minmax(90px, 16.5vh); gap:var(--gap);}
  .cell{border-radius:14px; background:linear-gradient(180deg,#fff,#f9fbff); border:2px dashed #cbd5ff;
    display:flex; align-items:center; justify-content:center; user-select:none; touch-action:manipulation; position:relative;}
  .cell:not(.active) {touch-action: auto;}
  .cell .cnt{font-size:1.35rem; color:#374151}
  .cell.active{ border:3px solid var(--accent); box-shadow:0 0 0 4px rgba(43,110,246,.12) }
  .cell.active::after{content:"Активно"; position:absolute; top:6px; right:8px; font-size:.72rem; color:#1e40af; background:#eef2ff; padding:2px 8px; border-radius:999px;}
  .stats{display:grid; grid-template-columns:1fr 1fr; gap:8px}
  .muted{color:var(--muted)}
  /* Removed details/summary styles - results always visible now */
  .tbl{width:100%; border-collapse:collapse}
  .tbl th,.tbl td{border-bottom:1px solid #eee; padding:6px 8px; font-size:.9rem; vertical-align:top}
  
  /* Mobile test mode - hide everything except tapping areas and stop button */
  @media (max-width: 768px) {
    body.test-mode .wrap > *:not(.grid):not(.mobile-controls) { display: none !important; }
    body.test-mode .wrap { padding: 5px; gap: 10px; justify-content: center; }
    body.test-mode .grid { flex: 1; max-height: calc(100vh - 80px); }
    body.test-mode .mobile-controls { 
      position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); 
      z-index: 1000; display: flex; gap: 10px; align-items: center;
      background: rgba(255,255,255,0.95); padding: 10px 20px; border-radius: 20px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.15);
    }
    body.test-mode .mobile-timer { font-size: 1.2rem; font-weight: 600; color: var(--accent); }
  }
  
  /* Countdown overlay */
  .countdown-overlay {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.8); z-index: 2000;
    display: flex; align-items: center; justify-content: center;
    backdrop-filter: blur(2px);
  }
  .countdown-number {
    font-size: 8rem; font-weight: 900; color: #fff;
    text-shadow: 0 4px 20px rgba(0,0,0,0.5);
    animation: countdownPulse 1s ease-in-out;
  }
  @keyframes countdownPulse {
    0% { transform: scale(0.5); opacity: 0; }
    50% { transform: scale(1.2); opacity: 1; }
    100% { transform: scale(1); opacity: 1; }
  }
  @media (max-width: 768px) {
    .countdown-number { font-size: 6rem; }
  }
  
  /* Responsive table for mobile */
  .table-container {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }
  @media (max-width: 768px) {
    .table-container {
      margin: 0 -10px;
      padding: 0 10px;
    }
    .tbl {
      min-width: 600px;
      font-size: 0.8rem;
    }
    .tbl th, .tbl td {
      padding: 4px 6px;
      white-space: nowrap;
    }
    .intervals-col {
      max-width: 120px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  }
  
  /* Delete button styling */
  .delete-btn {
    background: transparent;
    border: none;
    color: #ef4444;
    cursor: pointer;
    font-size: 1rem;
    padding: 2px 4px;
    border-radius: 4px;
    transition: all 0.2s;
  }
  .delete-btn:hover {
    background: #fef2f2;
    color: #dc2626;
  }
  
  /* Mobile button layout fixes */
  @media (max-width: 768px) {
    /* Only apply to action buttons row, not form row */
    .action-buttons.row {
      flex-direction: column;
      gap: 8px;
    }
    .action-buttons button {
      width: 100%;
      text-align: center;
      font-size: 1rem;
      padding: 14px 16px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    /* Stack buttons vertically on mobile for better touch targets */
    .action-buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    /* Fix form layout on mobile */
    .card .row:not(.action-buttons) {
      flex-direction: column;
      align-items: stretch !important;
      gap: 12px;
    }
    .card .row:not(.action-buttons) > div {
      min-width: auto;
      width: 100%;
    }
    /* Ensure input-group works properly on mobile */
    .input-group {
      width: 100%;
    }
    .action-buttons button {
      min-height: 48px; /* Better touch target */
    }
    /* Fix counter width on mobile to prevent jumping */
    .cell .cnt {
      min-width: 2ch;
      text-align: center;
      font-variant-numeric: tabular-nums;
    }
    @media (max-width: 480px) {
      .cell .cnt {
        min-width: 3ch;
        font-size: 1.5rem;
      }
    }
    /* Enhanced start button for mobile */
    .startbar {
      flex-direction: column;
      padding: 16px 0;
    }
    .startbar .primary {
      font-size: 1.2rem;
      font-weight: 600;
      padding: 16px 32px;
      min-height: 56px;
      width: 100%;
      max-width: 280px;
      box-shadow: 0 4px 12px rgba(22, 163, 74, 0.3);
      border-radius: 16px;
    }
    .startbar .primary:hover {
      box-shadow: 0 6px 16px rgba(22, 163, 74, 0.4);
      transform: translateY(-1px);
    }
  }
  
  /* QR Code styles - only show on desktop */
  .qr-mobile-card {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    position: relative;
    overflow: visible;
    padding: 16px 10px;
  }
  .qr-mobile-card::before {
    content: '';
    position: absolute;
    top: -50%;
    right: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
    pointer-events: none;
  }
  .qr-content {
    display: flex;
    align-items: center;
    gap: 16px;
    position: relative;
    z-index: 1;
    min-height: 140px;
    padding: 8px 0;
  }
  .qr-info {
    flex: 1;
  }
  .qr-title {
    font-size: 1.1rem;
    font-weight: 600;
    margin: 0 0 4px 0;
    color: white;
  }
  .qr-subtitle {
    font-size: 0.9rem;
    opacity: 0.9;
    margin: 0;
  }
  .qr-code-container {
    background: white;
    padding: 12px;
    border-radius: 12px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  }
  .qr-code-container img {
    display: block;
    width: 120px;
    height: 120px;
  }
  
  /* Hide QR code on mobile devices */
  @media (max-width: 768px) {
    .qr-mobile-card {
      display: none !important;
    }
  }
  
  /* Psychological Feedback Styles */
  .feedback-card {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    position: relative;
    overflow: visible;
    margin-top: 8px;
    padding: 20px 10px;
    min-height: auto;
    animation: slideInUp 0.5s ease-out;
  }
  
  .feedback-card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: radial-gradient(circle at top right, rgba(255,255,255,0.1) 0%, transparent 70%);
    pointer-events: none;
    border-radius: 12px;
  }
  
  .feedback-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 16px;
    position: relative;
    z-index: 1;
  }
  
  .feedback-icon {
    font-size: 2rem;
    animation: pulse 2s infinite;
  }
  
  .feedback-header h3 {
    margin: 0;
    font-size: 1.2rem;
    font-weight: 600;
  }
  
  .feedback-content {
    position: relative;
    z-index: 1;
    line-height: 1.6;
  }
  
  .feedback-metric {
    background: rgba(255,255,255,0.15);
    border-radius: 10px;
    padding: 12px;
    margin-bottom: 12px;
    backdrop-filter: blur(10px);
  }
  
  .feedback-metric strong {
    display: block;
    font-size: 1.8rem;
    margin-bottom: 4px;
  }
  
  .feedback-metric .label {
    font-size: 0.9rem;
    opacity: 0.95;
  }
  
  .feedback-interpretation {
    background: rgba(255,255,255,0.1);
    border-left: 4px solid rgba(255,255,255,0.5);
    padding: 12px;
    border-radius: 8px;
    margin: 16px 0;
  }
  
  .feedback-interpretation p {
    margin: 8px 0;
  }
  
  .feedback-interpretation p:first-child {
    margin-top: 0;
  }
  
  .feedback-interpretation p:last-child {
    margin-bottom: 0;
  }
  
  .feedback-note {
    font-size: 0.85rem;
    opacity: 0.9;
    font-style: italic;
    margin-top: 12px;
    padding-top: 12px;
    border-top: 1px solid rgba(255,255,255,0.2);
  }
  
  @keyframes slideInUp {
    from {
      transform: translateY(20px);
      opacity: 0;
    }
    to {
      transform: translateY(0);
      opacity: 1;
    }
  }
  
  @keyframes pulse {
    0%, 100% {
      transform: scale(1);
    }
    50% {
      transform: scale(1.1);
    }
  }
  
  /* Fix mobile scrolling issues */
  @media (max-width: 768px) {
    body {
      -webkit-overflow-scrolling: touch;
      overflow-y: auto;
      touch-action: pan-y;
    }
    .wrap {
      overflow-y: auto;
      -webkit-overflow-scrolling: touch;
    }
    .feedback-card {
      margin-top: 8px;
      padding: 16px 10px;
    }
    .feedback-icon {
      font-size: 1.5rem;
    }
    .feedback-header h3 {
      font-size: 1.1rem;
    }
    .feedback-metric strong {
      font-size: 1.5rem;
    }
  }
</style>
</head>
<body>
<div class="wrap">

  <div class="card hdr">
    <h1>Тепінг-тест Ільїна (30 с, 6 інтервалів × 5 с)</h1>
    <span class="pill">Протокол: 30 с · крок 5 с · 6 квадратів</span>
  </div>

  <!-- QR Code for Mobile Access - Desktop Only -->
  <div class="card qr-mobile-card">
    <div class="qr-content">
      <div class="qr-info">
        <h3 class="qr-title">📱 Обов'язково на мобільному!</h3>
        <p class="qr-subtitle">Тест необхідно проводити на телефоні для точних результатів. Відскануйте QR-код.</p>
      </div>
      <div class="qr-code-container">
        <img src="https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=https%3A//yoctoalex.github.io/tapping-test/" alt="QR код для мобільної версії" />
      </div>
    </div>
  </div>

  <div class="card">
    <div class="row" style="align-items:end;">
      <div style="flex:1; min-width:160px;">
        <label>Ідентифікатор учасника</label>
        <div class="input-group">
          <input id="pid" placeholder="Генерується автоматично" readonly />
          <button type="button" class="copy-btn" id="copyBtn">copy</button>
        </div>
      </div>
      <div style="min-width:150px;">
        <label>Рука</label>
        <select id="hand">
          <option value="right">права</option>
          <option value="left">ліва</option>
        </select>
      </div>
      <div style="min-width:120px;">
        <label>Проба</label>
        <select id="trial"><option>1</option><option>2</option><option>3</option></select>
      </div>
      <div style="min-width:140px;">
        <label>Таймер</label>
        <div class="timer" id="timer">30.0 с</div>
      </div>
    </div>
    <div class="startbar" style="margin-top:6px;">
      <button class="primary" id="startBtn">Старт</button>
    </div>
    <div class="small" style="margin-top:4px;">Тисни якомога швидше в <strong>підсвічений</strong> квадрат. Один палець.</div>
  </div>

  <div class="grid" id="grid">
    <div class="cell" data-idx="0"><div class="cnt" id="c0">0</div></div>
    <div class="cell" data-idx="1"><div class="cnt" id="c1">0</div></div>
    <div class="cell" data-idx="2"><div class="cnt" id="c2">0</div></div>
    <div class="cell" data-idx="3"><div class="cnt" id="c3">0</div></div>
    <div class="cell" data-idx="4"><div class="cnt" id="c4">0</div></div>
    <div class="cell" data-idx="5"><div class="cnt" id="c5">0</div></div>
  </div>

  <!-- Mobile controls shown during test -->
  <div class="mobile-controls" id="mobileControls" style="display:none;">
    <div class="mobile-timer" id="mobileTimer">30.0 с</div>
    <button class="primary" id="mobileStopBtn">Стоп</button>
  </div>

  <!-- Countdown overlay -->
  <div class="countdown-overlay" id="countdownOverlay" style="display:none;">
    <div class="countdown-number" id="countdownNumber">3</div>
  </div>

  <!-- Psychological Feedback Card - shown after test completion -->
  <div class="card feedback-card" id="feedbackCard" style="display:none;">
    <div class="feedback-header">
      <span class="feedback-icon">🧠</span>
      <h3>Ваш психологічний профіль</h3>
    </div>
    <div class="feedback-content" id="feedbackContent">
      <!-- Dynamic content will be inserted here -->
    </div>
  </div>

  <div class="card stats">
    <div>
      Всього натискань: <strong id="total">0</strong><br/>
      Індекс стомлюваності: <span id="fatigue" class="mono">—</span>
    </div>
    <div>
      <div><strong>Інтервали (по 5 с):</strong></div>
      <div id="intervals" class="mono small muted">— немає даних —</div>
    </div>
  </div>

  <div class="card small">
    <strong>Інструкція:</strong> 30 секунд поспіль швидко торкайся підсвіченого квадрата.
    Кожні 5 секунд активується наступний за схемою «П»: <em>знизу вгору лівий стовпець → зверху вправо</em>.
  </div>

  <div class="card small">
    <div class="row action-buttons" style="gap:6px; flex-wrap:wrap;">
      <button id="copyLatestBtn" class="primary" disabled>Копіювати останній результат</button>
      <button id="showLatestBtn" class="secondary" disabled>Відобразити останній результат</button>
      <button id="exportBtn" class="secondary">Завантажити всі як CSV</button>
      <button id="clearBtn" class="danger">Очистити всі збережені</button>
    </div>
    <div style="margin-top:12px;">
      <div style="margin-bottom:8px; font-weight:600; color:var(--fg);">Збережені спроби</div>
      <div class="table-container">
        <table class="tbl">
          <thead><tr><th>PID</th><th>рука</th><th>проба</th><th>усього</th><th class="intervals-col">інтервали</th><th>F, %</th><th>дата</th><th></th></tr></thead>
          <tbody id="runsBody"><tr><td colspan="8" class="small muted">Ще немає збережених спроб</td></tr></tbody>
        </table>
      </div>
    </div>
  </div>

</div>

<script>
(() => {
  const TOTAL_S = 30, STEP_S = 5, N = TOTAL_S / STEP_S;
  const ORDER = [4,2,0,1,3,5]; // схема "П"
  const pidEl=document.getElementById('pid'), handEl=document.getElementById('hand'), trialEl=document.getElementById('trial');
  
  // Auto-generate and manage user ID
  function generateUserId() {
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 4);
    return `P${timestamp}${random}`.toUpperCase();
  }
  
  function loadOrGenerateUserId() {
    let userId = localStorage.getItem('tapping_user_id');
    if (!userId) {
      userId = generateUserId();
      localStorage.setItem('tapping_user_id', userId);
    }
    return userId;
  }
  
  // Save and load current test state
  function saveCurrentState() {
    const state = {
      counts: counts.slice(),
      tapsTimestamps: tapsTimestamps.slice(),
      started: started,
      startAt: startAt,
      activeIdx: activeIdx,
      hand: handEl.value,
      trial: +trialEl.value,
      timestamp: Date.now()
    };
    localStorage.setItem('tapping_current_state', JSON.stringify(state));
  }
  
  function loadPreviousState() {
    const stateStr = localStorage.getItem('tapping_current_state');
    if (!stateStr) return false;
    
    try {
      const state = JSON.parse(stateStr);
      // Check if state is recent (within last 24 hours)
      if (Date.now() - state.timestamp > 24 * 60 * 60 * 1000) {
        localStorage.removeItem('tapping_current_state');
        return false;
      }
      
      counts = state.counts || Array.from({length:N},()=>0);
      tapsTimestamps = state.tapsTimestamps || [];
      handEl.value = state.hand || 'right';
      trialEl.value = state.trial || 1;
      
      // Update UI
      updateUIFromState();
      
      const total = counts.reduce((a,b)=>a+b,0);
      if (total > 0) {
        copyLatestBtn.disabled = false;
      }
      // Also check if there are any saved results to enable copy button
      const arr = JSON.parse(localStorage.getItem('tapping_runs_iljin_v1') || '[]');
      if (arr.length > 0) {
        copyLatestBtn.disabled = false;
      }
      
      return true;
    } catch (e) {
      localStorage.removeItem('tapping_current_state');
      return false;
    }
  }
  
  function updateUIFromState() {
    // Update counters display
    counts.forEach((count, i) => {
      document.getElementById('c' + ORDER[i]).textContent = count;
    });
    
    // Update total
    const total = counts.reduce((a,b)=>a+b,0);
    totalEl.textContent = total;
    
    // Update intervals and fatigue
    renderIntervals();
  }
  
  function clearCurrentState() {
    localStorage.removeItem('tapping_current_state');
  }
  
  // Mobile test mode functions
  function isMobile() {
    return window.innerWidth <= 768;
  }
  
  function enterMobileTestMode() {
    if (isMobile()) {
      document.body.classList.add('test-mode');
      document.getElementById('mobileControls').style.display = 'flex';
      // Prevent scrolling during test
      document.body.style.overflow = 'hidden';
    }
  }
  
  function exitMobileTestMode() {
    document.body.classList.remove('test-mode');
    document.getElementById('mobileControls').style.display = 'none';
    document.body.style.overflow = '';
    // Ensure mobile timer is also reset
    const mobileTimer = document.getElementById('mobileTimer');
    if (mobileTimer) {
      mobileTimer.textContent = '30.0 с';
    }
  }
  
  function updateMobileTimer() {
    if (isMobile()) {
      const mobileTimer = document.getElementById('mobileTimer');
      if (mobileTimer) {
        mobileTimer.textContent = timerEl.textContent;
      }
    }
  }
  
  // Countdown functionality
  function showCountdown(callback) {
    const overlay = document.getElementById('countdownOverlay');
    const numberEl = document.getElementById('countdownNumber');
    let count = 3;
    
    overlay.style.display = 'flex';
    
    function updateCountdown() {
      if (count > 0) {
        numberEl.textContent = count;
        // Trigger animation by removing and adding class
        numberEl.style.animation = 'none';
        numberEl.offsetHeight; // Trigger reflow
        numberEl.style.animation = 'countdownPulse 1s ease-in-out';
        count--;
        setTimeout(updateCountdown, 1000);
      } else {
        overlay.style.display = 'none';
        callback();
      }
    }
    
    updateCountdown();
  }
  
  // Copy latest result functionality
  async function copyLatestResult() {
    const arr = JSON.parse(localStorage.getItem('tapping_runs_iljin_v1') || '[]');
    if (arr.length === 0) {
      alert('Немає збережених результатів');
      return;
    }
    
    const latest = arr[arr.length - 1];
    const resultText = `Тепінг-тест Ільїна - Результат
` +
      `ID: ${latest.pid}\n` +
      `Рука: ${latest.hand === 'right' ? 'права' : 'ліва'}\n` +
      `Проба: ${latest.trial}\n` +
      `Усього натискань: ${latest.total}\n` +
      `Індекс стомлюваності: ${(latest.F >= 0 ? '+' : '')}${latest.F}%\n` +
      `Інтервали (${latest.step}с): ${latest.counts.join(', ')}\n` +
      `Дата: ${new Date(latest.ts).toLocaleString()}`;
    
    try {
      await navigator.clipboard.writeText(resultText);
      showCopyFeedback();
    } catch (err) {
      // Fallback for older browsers
      const textarea = document.createElement('textarea');
      textarea.value = resultText;
      document.body.appendChild(textarea);
      textarea.select();
      document.execCommand('copy');
      document.body.removeChild(textarea);
      showCopyFeedback();
    }
  }
  
  function showCopyFeedback() {
    const feedback = document.createElement('div');
    feedback.textContent = 'Result copied to clipboard ✓';
    feedback.style.cssText = `
      position: fixed; top: 20px; right: 20px; z-index: 3000;
      background: #dcfce7; color: #166534; padding: 12px 20px;
      border-radius: 10px; font-size: 0.9rem; font-weight: 600;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      animation: slideInRight 0.3s ease-out;
    `;
    
    document.body.appendChild(feedback);
    setTimeout(() => {
      feedback.style.animation = 'slideOutRight 0.3s ease-in';
      setTimeout(() => feedback.remove(), 300);
    }, 2500);
  }
  

  
    // Auto-save functionality
  function autoSave() {
    const total=counts.reduce((a,b)=>a+b,0);
    if(total===0){saveBtn.disabled=false;return;}
    
    const fatigueIdx = fatigueIndex(counts);
    const run={pid:pidEl.value.trim(),hand:handEl.value,trial:+trialEl.value,duration:TOTAL_S,step:STEP_S,counts:counts.slice(),total,F:+fatigueIdx.toFixed(1),
      times:tapsTimestamps.slice(),device:navigator.userAgent,ts:new Date().toISOString()};
    const KEY='tapping_runs_iljin_v1';const arr=JSON.parse(localStorage.getItem(KEY)||'[]');arr.push(run);localStorage.setItem(KEY,JSON.stringify(arr));
    renderRuns();copyLatestBtn.disabled=false;showLatestBtn.disabled=false;clearCurrentState();
    
    // Generate psychological feedback
    generatePsychologicalFeedback(counts, total, fatigueIdx);
    
    // Show auto-save feedback
    showAutoSaveFeedback();
  }

  // Psychological Feedback Generator
  function generatePsychologicalFeedback(counts, total, fatigueIdx) {
    const feedbackCard = document.getElementById('feedbackCard');
    const feedbackContent = document.getElementById('feedbackContent');
    
    // Calculate extended metrics for deeper analysis
    const firstHalf = counts.slice(0, 3).reduce((a, b) => a + b, 0);
    const secondHalf = counts.slice(3).reduce((a, b) => a + b, 0);
    const avgTaps = total / counts.length;
    const maxTaps = Math.max(...counts);
    const minTaps = Math.min(...counts);
    const variation = maxTaps - minTaps;
    const variationPercent = (variation / avgTaps * 100).toFixed(0);
    
    // New metrics for deeper analysis
    const firstInterval = counts[0];
    const lastInterval = counts[counts.length - 1];
    const middleIntervals = counts.slice(1, -1).reduce((a, b) => a + b, 0) / (counts.length - 2);
    
    // Calculate tempo stability (standard deviation)
    const mean = total / counts.length;
    const variance = counts.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / counts.length;
    const stdDev = Math.sqrt(variance);
    const stabilityCoef = (stdDev / mean * 100).toFixed(0);
    
    // Peak performance analysis
    const peakIndex = counts.indexOf(maxTaps);
    const peakTiming = peakIndex < 2 ? 'початок' : peakIndex < 4 ? 'середина' : 'кінець';
    
    // Recovery analysis (if there's a dip and recovery)
    let hasRecovery = false;
    for (let i = 1; i < counts.length - 1; i++) {
      if (counts[i] < counts[i-1] && counts[i+1] > counts[i]) {
        hasRecovery = true;
        break;
      }
    }
    
    // Momentum analysis
    const momentum = ((lastInterval - firstInterval) / firstInterval * 100).toFixed(0);
    
    // Determine profile type based on pattern
    let profileType = '';
    let strategyText = '';
    let attentionText = '';
    let enduranceText = '';
    let rhythmText = '';
    let peakText = '';
    let recoveryText = '';
    
    // Profile analysis with extended criteria
    if (fatigueIdx < -10) {
      profileType = 'Прогресивний';
      strategyText = 'Ви стартуєте обережно, а потім «розігріваєтесь» і входите в ритм. Це стратегія «марафонця» — ви вмієте розподіляти сили та нарощувати темп поступово.';
      attentionText = 'Ваша увага покращується з часом — ви потребуєте трохи часу для концентрації, але потім показуєте стабільний результат.';
    } else if (fatigueIdx > 15) {
      profileType = 'Спринтерський';
      strategyText = 'Ви стартуєте швидко й потужно, викладаючись одразу. Це стратегія «спринтера» — максимальна мобілізація на початку з природним спадом наприкінці.';
      attentionText = 'Ви швидко включаєтесь у роботу, але увага втомлюється наприкінці. Це природно й типово для людей з високою початковою мобілізацією.';
    } else if (stabilityCoef < 15) {
      profileType = 'Стабільний';
      strategyText = 'Ваш темп залишається рівним упродовж усього тесту — це ознака вміння тримати баланс і розподіляти сили. Ви добре контролюєте свій ритм.';
      attentionText = 'Ваша увага залишається стабільною протягом усього завдання. Ви здатні утримувати концентрацію та не піддаватись втомі 🧘.';
    } else {
      profileType = 'Адаптивний';
      strategyText = 'Ваш темп змінюється протягом тесту — ви адаптуєтесь до завдання та шукаєте оптимальний ритм. Це гнучкий підхід до виконання.';
      attentionText = 'Ваша увага має хвильовий характер — періоди високої концентрації чергуються з короткими спадами. Це нормальна динаміка роботи нервової системи.';
    }
    
    // Endurance analysis with more detail
    if (total > 250) {
      enduranceText = `Високий загальний результат (${total} натискань) свідчить про відмінну психомоторну витривалість та швидкість реакції. Ваша нервова система працює на високій частоті.`;
    } else if (total > 200) {
      enduranceText = `Хороший результат (${total} натискань) показує збалансовану роботу нервової системи та достатню витривалість. Ви маєте оптимальний баланс швидкості та контролю.`;
    } else if (total > 150) {
      enduranceText = `Ваш результат (${total} натискань) відображає спокійний, розмірений стиль роботи. Ви не поспішаєте, але виконуєте завдання стабільно та усвідомлено.`;
    } else {
      enduranceText = `Ваш результат (${total} натискань) може свідчити про обережний підхід або втому. Рекомендується повторити тест після відпочинку для порівняння.`;
    }
    
    // Rhythm analysis
    if (stabilityCoef < 10) {
      rhythmText = `Ваш ритм надзвичайно стабільний (коефіцієнт варіації ${stabilityCoef}%) — це ознака відмінного самоконтролю та внутрішнього метронома.`;
    } else if (stabilityCoef < 20) {
      rhythmText = `У вас хороший ритм з невеликими коливаннями (варіація ${stabilityCoef}%) — це нормальна робота здорової нервової системи.`;
    } else if (stabilityCoef < 30) {
      rhythmText = `Помірна варіативність темпу (${stabilityCoef}%) вказує на адаптивність вашої нервової системи до змінних умов.`;
    } else {
      rhythmText = `Висока варіативність темпу (${stabilityCoef}%) може свідчити про емоційність або творчий тип нервової системи, яка швидко реагує на внутрішні імпульси.`;
    }
    
    // Peak performance timing analysis
    if (peakTiming === 'початок') {
      peakText = `Ваш пік продуктивності припадає на початок роботи — ви здатні швидко мобілізуватись і видавати максимум одразу.`;
    } else if (peakTiming === 'середина') {
      peakText = `Пік вашої продуктивності в середині тесту — це оптимальний розподіл сил, коли ви вже розігрілись, але ще не втомились.`;
    } else {
      peakText = `Цікаво, що ваш пік продуктивності наприкінці тесту — можливо, ви відчули наближення фінішу і мобілізували резерви.`;
    }
    
    // Recovery ability
    if (hasRecovery) {
      recoveryText = `Помічена здатність до відновлення темпу після спаду — це ознака гнучкості та резервів вашої нервової системи.`;
    } else if (variation < avgTaps * 0.1) {
      recoveryText = `Стабільний темп без значних спадів показує хорошу витривалість без потреби в відновленні протягом короткого тесту.`;
    } else {
      recoveryText = `Лінійна динаміка без відновлення темпу — типовий патерн короткого тесту, де організм працює на одному диханні.`;
    }
    
    // Additional insights based on specific patterns
    let additionalInsights = '';
    
    // Check for warm-up effect
    if (counts[1] > counts[0] * 1.1) {
      additionalInsights += `<p><strong>🔥 Ефект розігріву:</strong> Помітне покращення в другому інтервалі (+${((counts[1] - counts[0]) / counts[0] * 100).toFixed(0)}%) — вашій нервовій системі потрібен час для оптимального включення.</p>`;
    }
    
    // Check for final sprint
    if (lastInterval > counts[counts.length - 2] * 1.1) {
      additionalInsights += `<p><strong>🏃 Фінішний ривок:</strong> Прискорення в останньому інтервалі (+${((lastInterval - counts[counts.length - 2]) / counts[counts.length - 2] * 100).toFixed(0)}%) — ви вмієте мобілізувати резерви перед завершенням.</p>`;
    }
    
    // Check for consistency in middle
    const middleVariation = Math.max(...counts.slice(1, -1)) - Math.min(...counts.slice(1, -1));
    if (middleVariation < avgTaps * 0.1) {
      additionalInsights += `<p><strong>⚖️ Стабільна середина:</strong> Середні інтервали майже ідентичні (різниця ${middleVariation} тапів) — ознака відмінного контролю темпу.</p>`;
    }
    
    // Neurotype suggestion
    let neurotype = '';
    if (total > 240 && stabilityCoef < 15) {
      neurotype = `<p><strong>🧬 Нейротип:</strong> Сильний врівноважений рухливий тип нервової системи — поєднання високої швидкості та стабільності.</p>`;
    } else if (total > 240 && stabilityCoef > 25) {
      neurotype = `<p><strong>🧬 Нейротип:</strong> Сильний неврівноважений тип — висока швидкість з елементами імпульсивності.</p>`;
    } else if (total < 180 && stabilityCoef < 15) {
      neurotype = `<p><strong>🧬 Нейротип:</strong> Врівноважений інертний тип — стабільність важливіша за швидкість, надійність у монотонній роботі.</p>`;
    } else if (fatigueIdx > 20) {
      neurotype = `<p><strong>🧬 Нейротип:</strong> Слабкий тип нервової системи — швидка мобілізація, але й швидке виснаження. Потребує частих перерв для відновлення.</p>`;
    }
    
    // Generate HTML content with extended analysis
    const feedbackHTML = `
      <div class="feedback-metric">
        <strong>${total}</strong>
        <span class="label">загальна кількість натискань</span>
      </div>
      
      <div class="feedback-metric">
        <strong>${profileType} тип</strong>
        <span class="label">ваш психомоторний профіль</span>
      </div>
      
      <div class="feedback-interpretation">
        <p><strong>📊 Стратегія виконання:</strong> ${strategyText}</p>
        <p><strong>🎯 Увага і концентрація:</strong> ${attentionText}</p>
        <p><strong>💪 Витривалість:</strong> ${enduranceText}</p>
        <p><strong>🎵 Ритмічність:</strong> ${rhythmText}</p>
        <p><strong>⚡ Пікова продуктивність:</strong> ${peakText}</p>
        <p><strong>🔄 Відновлення:</strong> ${recoveryText}</p>
        <p><strong>📈 Індекс стомлюваності (${(fatigueIdx >= 0 ? '+' : '')}${fatigueIdx.toFixed(1)}%):</strong> ${
          fatigueIdx < -5 ? 'Ваша система набирає темп під час роботи — це ознака хорошої адаптації до навантаження.' :
          fatigueIdx > 10 ? 'Помітне зниження темпу наприкінці — ваша система швидко витрачає ресурси, але це нормально для інтенсивної роботи.' :
          'Невисокий індекс стомлюваності — ви добре витримуєте коротке навантаження та зберігаєте працездатність.'
        }</p>
        ${additionalInsights}
        ${neurotype}
      </div>
      
      <div class="feedback-note">
        💡 Тепінг-тест відображає індивідуальний стиль роботи вашої нервової системи. Результати можуть змінюватись залежно від сну, стресу, настрою чи фізичного стану. Кожен профіль має свої переваги — важливо знати свої особливості та використовувати їх ефективно.
      </div>
    `;
    
    feedbackContent.innerHTML = feedbackHTML;
    feedbackCard.style.display = 'block';
    
    // Scroll to feedback after a short delay
    setTimeout(() => {
      feedbackCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, 300);
  }
  
  // Hide feedback when starting new test
  function hideFeedback() {
    const feedbackCard = document.getElementById('feedbackCard');
    feedbackCard.style.display = 'none';
  }

  // Show latest result feedback
  function showLatestResult() {
    const KEY='tapping_runs_iljin_v1';
    const runs = JSON.parse(localStorage.getItem(KEY) || '[]');
    if (runs.length === 0) {
      alert('Немає збережених результатів для відображення.');
      return;
    }
    
    const latestRun = runs[runs.length - 1];
    const counts = latestRun.counts || [];
    const total = latestRun.total || 0;
    const fatigueIdx = latestRun.F || 0;
    
    if (total === 0) {
      alert('Останній результат порожній.');
      return;
    }
    
    // Generate and show feedback for latest result
    generatePsychologicalFeedback(counts, total, fatigueIdx);
  }

  function generatePsychologicalFeedback(counts, total, fatigueIdx) {
    const feedbackCard = document.getElementById('feedbackCard');
    const feedbackContent = document.getElementById('feedbackContent');
    
    // Calculate extended metrics for deeper analysis
    const firstHalf = counts.slice(0, 3).reduce((a, b) => a + b, 0);
    const secondHalf = counts.slice(3).reduce((a, b) => a + b, 0);
    const avgTaps = total / counts.length;
    const maxTaps = Math.max(...counts);
    const minTaps = Math.min(...counts);
    const variation = maxTaps - minTaps;
    const variationPercent = (variation / avgTaps * 100).toFixed(0);
    
    // New metrics for deeper analysis
    const firstInterval = counts[0];
    const lastInterval = counts[counts.length - 1];
    const middleIntervals = counts.slice(1, -1).reduce((a, b) => a + b, 0) / (counts.length - 2);
    
    // Calculate tempo stability (standard deviation)
    const mean = total / counts.length;
    const variance = counts.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / counts.length;
    const stdDev = Math.sqrt(variance);
    const stabilityCoef = (stdDev / mean * 100).toFixed(0);
    
    // Peak performance analysis
    const peakIndex = counts.indexOf(maxTaps);
    const peakTiming = peakIndex < 2 ? 'початок' : peakIndex < 4 ? 'середина' : 'кінець';
    
    // Recovery analysis (if there's a dip and recovery)
    let hasRecovery = false;
    for (let i = 1; i < counts.length - 1; i++) {
      if (counts[i] < counts[i-1] && counts[i+1] > counts[i]) {
        hasRecovery = true;
        break;
      }
    }
    
    // Momentum analysis
    const momentum = ((lastInterval - firstInterval) / firstInterval * 100).toFixed(0);
    
    // Determine profile type based on pattern
    let profileType = '';
    let strategyText = '';
    let attentionText = '';
    let enduranceText = '';
    let rhythmText = '';
    let peakText = '';
    let recoveryText = '';
    
    // Profile analysis with extended criteria
    if (fatigueIdx < -10) {
      profileType = 'Прогресивний';
      strategyText = 'Ви стартуєте обережно, а потім «розігріваєтесь» і входите в ритм. Це стратегія «марафонця» — ви вмієте розподіляти сили та нарощувати темп поступово.';
      attentionText = 'Ваша увага покращується з часом — ви потребуєте трохи часу для концентрації, але потім показуєте стабільний результат.';
    } else if (fatigueIdx > 15) {
      profileType = 'Спринтерський';
      strategyText = 'Ви стартуєте швидко й потужно, викладаючись одразу. Це стратегія «спринтера» — максимальна мобілізація на початку з природним спадом наприкінці.';
      attentionText = 'Ви швидко включаєтесь у роботу, але увага втомлюється наприкінці. Це природно й типово для людей з високою початковою мобілізацією.';
    } else if (stabilityCoef < 15) {
      profileType = 'Стабільний';
      strategyText = 'Ваш темп залишається рівним упродовж усього тесту — це ознака вміння тримати баланс і розподіляти сили. Ви добре контролюєте свій ритм.';
      attentionText = 'Ваша увага залишається стабільною протягом усього завдання. Ви здатні утримувати концентрацію та не піддаватись втомі 🧘.';
    } else {
      profileType = 'Адаптивний';
      strategyText = 'Ваш темп змінюється протягом тесту — ви адаптуєтесь до завдання та шукаєте оптимальний ритм. Це гнучкий підхід до виконання.';
      attentionText = 'Ваша увага має хвильовий характер — періоди високої концентрації чергуються з короткими спадами. Це нормальна динаміка роботи нервової системи.';
    }
    
    // Endurance analysis with more detail
    if (total > 250) {
      enduranceText = `Високий загальний результат (${total} натискань) свідчить про відмінну психомоторну витривалість та швидкість реакції. Ваша нервова система працює на високій частоті.`;
    } else if (total > 200) {
      enduranceText = `Хороший результат (${total} натискань) показує збалансовану роботу нервової системи та достатню витривалість. Ви маєте оптимальний баланс швидкості та контролю.`;
    } else if (total > 150) {
      enduranceText = `Ваш результат (${total} натискань) відображає спокійний, розмірений стиль роботи. Ви не поспішаєте, але виконуєте завдання стабільно та усвідомлено.`;
    } else {
      enduranceText = `Ваш результат (${total} натискань) може свідчити про обережний підхід або втому. Рекомендується повторити тест після відпочинку для порівняння.`;
    }
    
    // Rhythm analysis
    if (stabilityCoef < 10) {
      rhythmText = `Ваш ритм надзвичайно стабільний (коефіцієнт варіації ${stabilityCoef}%) — це ознака відмінного самоконтролю та внутрішнього метронома.`;
    } else if (stabilityCoef < 20) {
      rhythmText = `У вас хороший ритм з невеликими коливаннями (варіація ${stabilityCoef}%) — це нормальна робота здорової нервової системи.`;
    } else if (stabilityCoef < 30) {
      rhythmText = `Помірна варіативність темпу (${stabilityCoef}%) вказує на адаптивність вашої нервової системи до змінних умов.`;
    } else {
      rhythmText = `Висока варіативність темпу (${stabilityCoef}%) може свідчити про емоційність або творчий тип нервової системи, яка швидко реагує на внутрішні імпульси.`;
    }
    
    // Peak performance timing analysis
    if (peakTiming === 'початок') {
      peakText = `Ваш пік продуктивності припадає на початок роботи — ви здатні швидко мобілізуватись і видавати максимум одразу.`;
    } else if (peakTiming === 'середина') {
      peakText = `Пік вашої продуктивності в середині тесту — це оптимальний розподіл сил, коли ви вже розігрілись, але ще не втомились.`;
    } else {
      peakText = `Цікаво, що ваш пік продуктивності наприкінці тесту — можливо, ви відчули наближення фінішу і мобілізували резерви.`;
    }
    
    // Recovery ability
    if (hasRecovery) {
      recoveryText = `Помічена здатність до відновлення темпу після спаду — це ознака гнучкості та резервів вашої нервової системи.`;
    } else if (variation < avgTaps * 0.1) {
      recoveryText = `Стабільний темп без значних спадів показує хорошу витривалість без потреби в відновленні протягом короткого тесту.`;
    } else {
      recoveryText = `Лінійна динаміка без відновлення темпу — типовий патерн короткого тесту, де організм працює на одному диханні.`;
    }
    
    // Additional insights based on specific patterns
    let additionalInsights = '';
    
    // Check for warm-up effect
    if (counts[1] > counts[0] * 1.1) {
      additionalInsights += `<p><strong>🔥 Ефект розігріву:</strong> Помітне покращення в другому інтервалі (+${((counts[1] - counts[0]) / counts[0] * 100).toFixed(0)}%) — вашій нервовій системі потрібен час для оптимального включення.</p>`;
    }
    
    // Check for final sprint
    if (lastInterval > counts[counts.length - 2] * 1.1) {
      additionalInsights += `<p><strong>🏃 Фінішний ривок:</strong> Прискорення в останньому інтервалі (+${((lastInterval - counts[counts.length - 2]) / counts[counts.length - 2] * 100).toFixed(0)}%) — ви вмієте мобілізувати резерви перед завершенням.</p>`;
    }
    
    // Check for consistency in middle
    const middleVariation = Math.max(...counts.slice(1, -1)) - Math.min(...counts.slice(1, -1));
    if (middleVariation < avgTaps * 0.1) {
      additionalInsights += `<p><strong>⚖️ Стабільна середина:</strong> Середні інтервали майже ідентичні (різниця ${middleVariation} тапів) — ознака відмінного контролю темпу.</p>`;
    }
    
    // Neurotype suggestion
    let neurotype = '';
    if (total > 240 && stabilityCoef < 15) {
      neurotype = `<p><strong>🧬 Нейротип:</strong> Сильний врівноважений рухливий тип нервової системи — поєднання високої швидкості та стабільності.</p>`;
    } else if (total > 240 && stabilityCoef > 25) {
      neurotype = `<p><strong>🧬 Нейротип:</strong> Сильний неврівноважений тип — висока швидкість з елементами імпульсивності.</p>`;
    } else if (total < 180 && stabilityCoef < 15) {
      neurotype = `<p><strong>🧬 Нейротип:</strong> Врівноважений інертний тип — стабільність важливіша за швидкість, надійність у монотонній роботі.</p>`;
    } else if (fatigueIdx > 20) {
      neurotype = `<p><strong>🧬 Нейротип:</strong> Слабкий тип нервової системи — швидка мобілізація, але й швидке виснаження. Потребує частих перерв для відновлення.</p>`;
    }
    
    // Generate HTML content with extended analysis
    const feedbackHTML = `
      <div class="feedback-metric">
        <strong>${total}</strong>
        <span class="label">загальна кількість натискань</span>
      </div>
      
      <div class="feedback-metric">
        <strong>${profileType} тип</strong>
        <span class="label">ваш психомоторний профіль</span>
      </div>
      
      <div class="feedback-interpretation">
        <p><strong>📊 Стратегія виконання:</strong> ${strategyText}</p>
        <p><strong>🎯 Увага і концентрація:</strong> ${attentionText}</p>
        <p><strong>💪 Витривалість:</strong> ${enduranceText}</p>
        <p><strong>🎵 Ритмічність:</strong> ${rhythmText}</p>
        <p><strong>⚡ Пікова продуктивність:</strong> ${peakText}</p>
        <p><strong>🔄 Відновлення:</strong> ${recoveryText}</p>
        <p><strong>📈 Індекс стомлюваності (${(fatigueIdx >= 0 ? '+' : '')}${fatigueIdx.toFixed(1)}%):</strong> ${
          fatigueIdx < -5 ? 'Ваша система набирає темп під час роботи — це ознака хорошої адаптації до навантаження.' :
          fatigueIdx > 10 ? 'Помітне зниження темпу наприкінці — ваша система швидко витрачає ресурси, але це нормально для інтенсивної роботи.' :
          'Невисокий індекс стомлюваності — ви добре витримуєте коротке навантаження та зберігаєте працездатність.'
        }</p>
        ${additionalInsights}
        ${neurotype}
      </div>
      
      <div class="feedback-note">
        💡 Тепінг-тест відображає індивідуальний стиль роботи вашої нервової системи. Результати можуть змінюватись залежно від сну, стресу, настрою чи фізичного стану. Кожен профіль має свої переваги — важливо знати свої особливості та використовувати їх ефективно.
      </div>
    `;
    
    feedbackContent.innerHTML = feedbackHTML;
    feedbackCard.style.display = 'block';
    
    // Scroll to feedback after a short delay
    setTimeout(() => {
      feedbackCard.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }, 300);
  }
  
  // Hide feedback when starting new test
  function hideFeedback() {
    const feedbackCard = document.getElementById('feedbackCard');
    feedbackCard.style.display = 'none';
  }
  
  function showAutoSaveFeedback() {
    // Create temporary feedback element
    const feedback = document.createElement('div');
    feedback.textContent = 'Результати автоматично збережено ✓';
    feedback.style.cssText = `
      position: fixed; top: 20px; right: 20px; z-index: 3000;
      background: #dcfce7; color: #166534; padding: 12px 20px;
      border-radius: 10px; font-size: 0.9rem; font-weight: 600;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      animation: slideInRight 0.3s ease-out;
    `;
    
    // Add animation keyframes if not already added
    if (!document.querySelector('#autoSaveStyles')) {
      const style = document.createElement('style');
      style.id = 'autoSaveStyles';
      style.textContent = `
        @keyframes slideInRight {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOutRight {
          from { transform: translateX(0); opacity: 1; }
          to { transform: translateX(100%); opacity: 0; }
        }
      `;
      document.head.appendChild(style);
    }
    
    document.body.appendChild(feedback);
    
    // Remove feedback after 3 seconds
    setTimeout(() => {
      feedback.style.animation = 'slideOutRight 0.3s ease-in';
      setTimeout(() => feedback.remove(), 300);
    }, 3000);
  }
  
  // Copy ID to clipboard
  async function copyIdToClipboard() {
    const copyBtn = document.getElementById('copyBtn');
    try {
      await navigator.clipboard.writeText(pidEl.value);
      copyBtn.textContent = 'copied';
      copyBtn.classList.add('copied');
      setTimeout(() => {
        copyBtn.textContent = 'copy';
        copyBtn.classList.remove('copied');
      }, 1500);
    } catch (err) {
      // Fallback for browsers that don't support clipboard API
      pidEl.select();
      document.execCommand('copy');
      copyBtn.textContent = 'copied';
      copyBtn.classList.add('copied');
      setTimeout(() => {
        copyBtn.textContent = 'copy';
        copyBtn.classList.remove('copied');
      }, 1500);
    }
  }
  const timerEl=document.getElementById('timer'), totalEl=document.getElementById('total'), intervalsEl=document.getElementById('intervals'), fatigueEl=document.getElementById('fatigue');
  const startBtn=document.getElementById('startBtn');
  const copyLatestBtn=document.getElementById('copyLatestBtn'), showLatestBtn=document.getElementById('showLatestBtn'), exportBtn=document.getElementById('exportBtn'), clearBtn=document.getElementById('clearBtn');
  const grid=document.getElementById('grid'), runsBody=document.getElementById('runsBody');
  let started=false, startAt=0, timerId=null, switchId=null, activeIdx=-1;
  let counts=Array.from({length:N},()=>0), tapsTimestamps=[];

  function fmtSec(s){return s.toFixed(1)+' с';}
  function setActiveCell(idx){activeIdx=idx;Array.from(grid.children).forEach((c,i)=>c.classList.toggle('active',i===idx));}
  function resetUI(){started=false;clearInterval(timerId);clearInterval(switchId);counts=Array.from({length:N},()=>0);tapsTimestamps=[];activeIdx=-1;
    Array.from(grid.children).forEach((c,i)=>{c.classList.remove('active');c.querySelector('.cnt').textContent='0';});
    timerEl.textContent=fmtSec(TOTAL_S);totalEl.textContent='0';intervalsEl.textContent='— немає даних —';fatigueEl.textContent='—';
    document.getElementById('countdownOverlay').style.display='none';exitMobileTestMode();startBtn.textContent='Старт';startBtn.disabled=false;copyLatestBtn.disabled=true;clearCurrentState();}
  function fatigueIndex(cnt){const f=cnt[0]||0,l=cnt[cnt.length-1]||0;return f?((l-f)/f*100):0;}
  function renderIntervals(){intervalsEl.textContent=counts.map((c,i)=>`${i*STEP_S}-${(i+1)*STEP_S} с: ${c}`).join(' | ');
    const F=fatigueIndex(counts);fatigueEl.textContent=(F>=0?'+':'')+F.toFixed(1)+' %';}
  function bump(i){counts[i]++;totalEl.textContent=counts.reduce((a,b)=>a+b,0);document.getElementById('c'+ORDER[i]).textContent=counts[i];renderIntervals();saveCurrentState();}
  function onTap(e){if(!started)return;const idx=+this.dataset.idx;if(idx!==activeIdx)return;
    e.preventDefault();const now=performance.now(),t=(now-startAt)/1000,i=Math.min(Math.floor(t/STEP_S),N-1);if(t>TOTAL_S)return;bump(i);tapsTimestamps.push(+t.toFixed(3));}
  Array.from(grid.children).forEach(c=>{c.addEventListener('touchstart',onTap,{passive:false});c.addEventListener('mousedown',onTap);});
  function updateTimer(){const now=performance.now(),el=(now-startAt)/1000,r=Math.max(0,TOTAL_S-el);timerEl.textContent=fmtSec(r);if(r<=0)stop();}
  function startTest() {
    resetUI();hideFeedback();started=true;startAt=performance.now();
    startBtn.textContent='Стоп';copyLatestBtn.disabled=true;setActiveCell(ORDER[0]);saveCurrentState();
    enterMobileTestMode();timerId=setInterval(()=>{updateTimer();updateMobileTimer();},50);let step=0;
    switchId=setInterval(()=>{step++;if(step>=N){stop();return;}setActiveCell(ORDER[step]);saveCurrentState();},STEP_S*1000);
  }
  
  function start(){if(started)return;showCountdown(startTest);}
  function stop(){if(!started)return;started=false;clearInterval(timerId);clearInterval(switchId);updateTimer();setActiveCell(-1);
    document.getElementById('countdownOverlay').style.display='none';exitMobileTestMode();const total=counts.reduce((a,b)=>a+b,0);
    if(total>0){autoSave();copyLatestBtn.disabled=false;}else{copyLatestBtn.disabled=true;}
    startBtn.textContent='Старт';}
  function saveRun(){const total=counts.reduce((a,b)=>a+b,0);if(total===0){alert('Немає даних');return;}
    const run={pid:pidEl.value.trim(),hand:handEl.value,trial:+trialEl.value,duration:TOTAL_S,step:STEP_S,counts:counts.slice(),total,F:+fatigueIndex(counts).toFixed(1),
      times:tapsTimestamps.slice(),device:navigator.userAgent,ts:new Date().toISOString()};
    const KEY='tapping_runs_iljin_v1';const arr=JSON.parse(localStorage.getItem(KEY)||'[]');arr.push(run);localStorage.setItem(KEY,JSON.stringify(arr));renderRuns();saveBtn.disabled=true;startBtn.textContent='Старт';clearCurrentState();}
  function renderRuns(){const arr=JSON.parse(localStorage.getItem('tapping_runs_iljin_v1')||'[]');if(!arr.length){runsBody.innerHTML='<tr><td colspan="8" class="small muted">Ще немає</td></tr>';return;}
    runsBody.innerHTML=arr.slice(-12).reverse().map((r,displayIndex)=>{
      const actualIndex = arr.length - 1 - displayIndex;
      return `<tr>
        <td>${r.pid||'—'}</td>
        <td>${r.hand}</td>
        <td>${r.trial}</td>
        <td>${r.total}</td>
        <td class="mono intervals-col">${r.counts.join(', ')}</td>
        <td>${(r.F>=0?'+':'')}${r.F}%</td>
        <td><span class="small muted">${new Date(r.ts).toLocaleString()}</span></td>
        <td><button class="delete-btn" data-index="${actualIndex}" title="Видалити">×</button></td>
      </tr>`;
    }).join('');}
  function exportCSV(){const arr=JSON.parse(localStorage.getItem('tapping_runs_iljin_v1')||'[]');if(!arr.length){alert('Немає спроб');return;}
    const m=Math.max(...arr.map(r=>r.counts.length)),header=['pid','hand','trial','duration_s','step_s','total','F_percent','ts','device',...Array.from({length:m},(_,i)=>`count_${i+1}`)];
    const rows=arr.map(r=>{const base=[r.pid,r.hand,r.trial,r.duration,r.step,r.total,r.F,r.ts,JSON.stringify(r.device)],cnt=r.counts.slice();while(cnt.length<m)cnt.push('');return base.concat(cnt);});
    const csv=[header].concat(rows).map(row=>row.map(c=>{const s=String(c??'');return(/["\n]/.test(s))?`"${s.replace(/"/g,'""')}"`:s;}).join(',')).join('\n');
    const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}),url=URL.createObjectURL(blob),a=document.createElement('a');a.href=url;a.download='tapping_iljin.csv';document.body.appendChild(a);a.click();a.remove();URL.revokeObjectURL(url);}
  function clearAll(){if(!confirm('Очистити всі?'))return;localStorage.removeItem('tapping_runs_iljin_v1');renderRuns();copyLatestBtn.disabled=true;showLatestBtn.disabled=true;}
  function toggleStartStop(){if(started){stop();}else{start();}}
  startBtn.addEventListener('click',toggleStartStop);
  document.getElementById('copyBtn').addEventListener('click',copyIdToClipboard);
  document.getElementById('mobileStopBtn').addEventListener('click', function() {
    stop();
  });
  copyLatestBtn.addEventListener('click',copyLatestResult);showLatestBtn.addEventListener('click',showLatestResult);exportBtn.addEventListener('click',exportCSV);clearBtn.addEventListener('click',clearAll);
  
  // Initialize user ID on page load
  pidEl.value = loadOrGenerateUserId();
  
  // Load previous state if available, otherwise reset UI
  if (!loadPreviousState()) {
    resetUI();
  }
  renderRuns();
  
  // Enable copy and show buttons if there are saved results
  const arr = JSON.parse(localStorage.getItem('tapping_runs_iljin_v1') || '[]');
  if (arr.length > 0) {
    copyLatestBtn.disabled = false;
    showLatestBtn.disabled = false;
  }
  
  // Event delegation for delete buttons
  document.addEventListener('click', function(e) {
    if (e.target.classList.contains('delete-btn')) {
      const index = parseInt(e.target.dataset.index);
      deleteResult(index);
    }
  });
})();

// Global delete function
function deleteResult(index) {
  if (!confirm('Видалити цей результат?')) return;
  
  const KEY = 'tapping_runs_iljin_v1';
  const arr = JSON.parse(localStorage.getItem(KEY) || '[]');
  
  if (index >= 0 && index < arr.length) {
    arr.splice(index, 1);
    localStorage.setItem(KEY, JSON.stringify(arr));
    
    // Re-render the table
    const runsBody = document.getElementById('runsBody');
    if (!arr.length) {
      runsBody.innerHTML = '<tr><td colspan="8" class="small muted">Ще немає</td></tr>';
    } else {
      runsBody.innerHTML = arr.slice(-12).reverse().map((r, displayIndex) => {
        const actualIndex = arr.length - 1 - displayIndex;
        return `<tr>
          <td>${r.pid || '—'}</td>
          <td>${r.hand}</td>
          <td>${r.trial}</td>
          <td>${r.total}</td>
          <td class="mono intervals-col">${r.counts.join(', ')}</td>
          <td>${(r.F >= 0 ? '+' : '')}${r.F}%</td>
          <td><span class="small muted">${new Date(r.ts).toLocaleString()}</span></td>
          <td><button class="delete-btn" data-index="${actualIndex}" title="Видалити">×</button></td>
        </tr>`;
      }).join('');
    }
    
    // Update buttons state
    const copyLatestBtn = document.getElementById('copyLatestBtn');
    const showLatestBtn = document.getElementById('showLatestBtn');
    if (arr.length === 0) {
      copyLatestBtn.disabled = true;
      showLatestBtn.disabled = true;
    }
    
    // Show feedback
    const feedback = document.createElement('div');
    feedback.textContent = 'Результат видалено ✓';
    feedback.style.cssText = `
      position: fixed; top: 20px; right: 20px; z-index: 3000;
      background: #fef2f2; color: #dc2626; padding: 12px 20px;
      border-radius: 10px; font-size: 0.9rem; font-weight: 600;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
      animation: slideInRight 0.3s ease-out;
    `;
    
    document.body.appendChild(feedback);
    setTimeout(() => {
      feedback.style.animation = 'slideOutRight 0.3s ease-in';
      setTimeout(() => feedback.remove(), 300);
    }, 2500);
  }
}
</script>
</body>
</html>
